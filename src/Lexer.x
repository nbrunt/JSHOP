-- ******************************************************************************
-- *                                      JSHOP                                 *
-- *                                                                            *
-- *   Module:   Lexer                                                          *
-- *   Purpose:  JavaScript Lexical Analyser                                    *
-- *   Author:   Nick Brunt                                                     *
-- *                                                                            *
-- *                    Copyright (c) Nick Brunt, 2011 - 2012                   *
-- *              Subject to MIT License as stated in root directory            *
-- *                                                                            *
-- *                  The structure for this file was partially                 *
-- *                      determined from a Haskell lexer:                      *
-- *               http://darcs.haskell.org/alex/examples/haskell.x             *
-- *                                                                            *
-- ******************************************************************************

{
-- | JavaScript Lexical Analyser generated by Alex

module Lexer where

-- JSHOP module imports
import Token
}

%wrapper "basic"

-- Special characters
$whitechar = [ \t\n\r\f\v]
$spacechar = [ \t]
$special   = [\(\)\,\;\[\]\`\{\}]

$digit     = 0-9
$alpha     = [a-zA-Z]

-- Symbols are any of the following characters except (#) some special cases
$symbol    = [\!\#\$\%\&\*\+\.\/\<\=\>\?\@\\\^\|\-\~\,\;] # [$special \_\:\"\']

$graphic   = [$alpha $symbol $digit $special \_\:\"\'\,]

$octit	   = 0-7
$hexit     = [0-9 A-F a-f]
$nl        = [\n\r]

$charesc   = [abfnrtv\\\"\'\&\/]
@escape    = \\ ( $charesc | x $hexit+ )

@dString   = $graphic # [\"\\] | " " | $nl | @escape
@sString   = $graphic # [\'\\] | " " | $nl | @escape

-- As stated in JavaScript Pocket Reference (O'Reilly, David Flanagan, 2nd edition), page 3
@reservedid =
          break|case|catch|continue|default|delete|do|else|false|finally|for|function|if|in|
          instanceof|new|null|return|switch|this|throw|true|try|typeof|var|void|while|with|
          -- reserved words for possible future extensions
          abstract|boolean|byte|char|class|const|debugger|double|enum|export|extends|final|
          float|implements|import|int|interface|long|native|package|private|protected|public|
          short|static|super|synchronized|throws|transient|volatile|
          -- and finally, let's hope not
          goto

-- As stated in JavaScript Pocket Reference (O'Reilly, David Flanagan, 2nd edition), pages 10 and 11
@reservedop =
          "." | "[" | "]" | "(" | ")" | "++" | "--" | "-" | "+" | "~" | "!" | "*" | "/" | "%" |
          "<<" | ">>" | ">>>" | "<" | "<=" | ">" | ">=" | "==" | "!=" | "===" | "!==" | "&" |
          "^" | "|" | "&&" | "||" | "?" | ":" | "=" | "*=" | "+=" | "-=" | "/=" | "%=" | "<<=" |
          ">>=" | ">>=" | "&=" | "^=" | "|=" | "," | ";" | "{" | "}"

@decimal = $digit+
@float   = $digit* "." $digit+ ((e|E) ("+"|"-")? $digit+)?
@hex     = "0" ("x"|"X") $hexit+
-- Some versions of JavaScript support octals, some do not.
-- http://docstore.mik.ua/orelly/webprog/jscript/ch03_01.htm#jscript4-CHP-3-SECT-1
@oct     = "0" $octit+

-- "Identifiers are composed of any number of letters and digits, and _ and $ characters.  The
--  first character of an identifier must not be a digit, however."
-- From JavaScript Pocket Reference (O'Reilly, David Flanagan, 2nd edition), page 2
$firstLetter = [$alpha \_ \$]
@id          = $firstLetter [$alpha $digit \_ \$]*

-- This regular expression matches a JavaScript regular expression.  There were several
-- problems with matching regexs because you cannot specify context in the lexer.  I have
-- worked around this by specifying what the character following the regex is allowed to be
-- (see $reFollow).  This means I am matching one too many characters, so I have to correct
-- this in the lexer function (found in LexerMonad.hs).  This is the only solution available
-- beyond writing a whole lexer dedicated to regular expressions.
@reEscapedChar  = \\.
@reCharClass    = \[[^\]]*\]
@reBody         = @reEscapedChar | [^\[\/\\] | @reCharClass
@reMods         = "g" | "i" | "m"
$reFollow       = [\)\,\;\ \.\} $nl]
@regex          = \/ @reBody* \/ @reMods* $reFollow
-- Equivalent to \/(\\.|[^\[\/\\]|\[[^\]]*\])*\/[gim]*[\)\,\;\ \.\} $nl]

-- Capture any other unknown symbols
@other = $symbol

-- String -> Token
tokens :-
  <0>  "//" [$spacechar $printable]* $nl?    { \s -> SLCom }
  <0>  $white+                               { \s -> WS }
  <0>  @reservedid                           { \s -> ResId s }
  <0>  @reservedop                           { \s -> ResOp s }
  -- JavaScipt floats do not require zeros before the decimal point.  Haskell's floats do.
  <0>  @float                                { \s -> LitFloat (read ("0" ++ s) :: Double) }
  -- Read hex's and oct's in as integers.  Much easier to handle.
  <0>  @hex                                  { \s -> LitInt (read s :: Integer) }
  -- JavaScript notation for octals is 0 followed by [0..7]+, whereas Haskell's notation
  -- is 0o followed by [0..7]+.
  <0>  @oct                                  { \s -> LitInt (read ("0o" ++ tail s) :: Integer) }
  <0>  @decimal                              { \s -> LitInt (read s :: Integer) }
  <0>  @id                                   { \s -> Id s }
  <0>  \" @dString* \"                       { \s -> LitStr s }
  <0>  \' @sString* \'                       { \s -> LitStr s }
  <0>  @regex                                { \s -> Regex s }
  <0>  @other                                { \s -> Other s }
